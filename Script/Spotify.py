# -*- coding: utf-8 -*-
"""Spotify_15  & 25

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dDy8FxIgy2GIDPE8e-MNqC_rxMGJZDui
"""

!pip install kagglehub

import numpy as np
import pandas as pd
import os
import kagglehub
import zipfile
import statistics as stats
from kagglehub import KaggleDatasetAdapter
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import files
uploaded = files.upload()

import zipfile

with zipfile.ZipFile("archive (3).zip", "r") as z:
    z.extractall("data/")

os.listdir("data/")

df = pd.read_csv('data/spotify_2015_2025_85k.csv')
df

pd.to_datetime(df['release_date'], errors='coerce')
df['release_date'].dtypes

df.info()

df.head(10)

df.describe()

df.nunique()

df.isnull().sum()

df['release_date'] = pd.to_datetime(df['release_date'])

df.columns

df.dtypes['release_date']

df['track_name'] = df['track_name'].fillna('Unknown track')

df['album_name'] = df['album_name'].fillna('Unknown track')

df.isnull().sum().all()

df_new = df.nlargest(10, "popularity")[["track_name", "artist_name", "popularity"]].reset_index()
df_new

df.groupby("popularity")[['artist_name','country', 'label']].min().reset_index().head(10)

df.groupby("popularity")[['artist_name','country', 'label']].max().reset_index().head(10)

df.groupby("popularity").first().head()

df.groupby("popularity").last()

"""# **Most frequent artists in popular songs:**"""

df[df["popularity"]>=90]["artist_name"].value_counts().idxmax()

df[df["popularity"]>=90]["artist_name"].value_counts().idxmin()

"""**Country / Label analysis**"""

df.groupby("country")["popularity"].mean().sort_values(ascending=False).head(10)

import seaborn as sns
df_1=df.groupby("country")["popularity"].mean().sort_values(ascending=False).head(10).reset_index()
sns.scatterplot(x='country',y='popularity',data=df_1)
plt.xticks(rotation=90)

df.columns

df.groupby('artist_name')['stream_count'].agg(['mean','median','count']).sample(100)

Sample_1=df.groupby('artist_name')['stream_count'].count().reset_index().nlargest(10,'stream_count')
sns.barplot(x='artist_name',y='stream_count', data= Sample_1)
plt.xticks(rotation=120)

sample= df.groupby('artist_name')['popularity'].count().reset_index().sample(10)
sample

sns.barplot(x='artist_name',y='popularity', data=sample)
plt.xticks(rotation=120)

print(df['popularity'].nlargest(10))
print(df['stream_count'].nlargest())

corr_martrix= df.select_dtypes(include='number').corr()
sns.heatmap(corr_martrix, annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap")
plt.show()

"""Index(['track_id', 'track_name', 'artist_name', 'album_name', 'release_date',
       'genre', 'duration_ms', 'popularity', 'danceability', 'energy', 'key',
       'loudness', 'mode', 'instrumentalness', 'tempo', 'stream_count',
       'country', 'explicit', 'label'],
      dtype='object')
"""

num_cols = df.select_dtypes(include=['int64','float64']).columns
num_cols

""" outlier_cols :
'stream_count',
'duration_ms',
'loudness',
'tempo',
'instrumentalness'
"""

range=df['stream_count'].max()-df['stream_count'].min()
print("Range :", range)
print(df['stream_count'].agg(['mean','median']))
print("Variation is:",df['stream_count'].var())
print("Standard deviation :",df['stream_count'].std())
print("Skew :",df['stream_count'].skew())
print("cofficient of variantion :",df['stream_count'].std()/df['stream_count'].mean())   # data is highly right skew.
Q1=df['stream_count'].quantile(0.25)
Q3=df['stream_count'].quantile(0.75)
IQR= Q3-Q1
print("IQR :",IQR)
lower_fence = Q1-1.5*(IQR)
print("lower fence :",lower_fence)
upper_fence=Q3+1.5*(IQR)
print("upper fence :",upper_fence)

outlier=df[(df['stream_count']<lower_fence) | (df['stream_count']>upper_fence)]
outlier

sns.boxplot(y='stream_count',data = df)

Clear_data=df[(df['stream_count']>lower_fence) & (df['stream_count']<upper_fence)]
Clear_data #coloum stream_count's outlier removed

Clear_data.columns

sns.boxplot(y='stream_count',data=Clear_data) # visul representation of outliers for coloum stream_count

print("mean :",Clear_data['stream_count'].mean()) #new statistics of colum stream count has been reduced
print("median:",Clear_data['stream_count'].median())
print("Variation :",Clear_data['stream_count'].var())
print("standard devaintion :",Clear_data['stream_count'].std())
print("skew :",Clear_data['stream_count'].skew())

df.select_dtypes(include='number').corr()

print(df['duration_ms'].agg(['mean','median','var','std']))
print("mode is :",df['duration_ms'].mode())

print(df['duration_ms'].skew()) #Duration data is approximately symmetric with negligible skew, hence no aggressive outlier treatment is required.

colom = df.select_dtypes(include='number').columns.tolist()
colom

def calculation () :
    col = df[['loudness','tempo','instrumentalness']]

    print("Mean & Median:")
    print(col.agg(['mean', 'median']))

    print("\nVariance:")
    print(col.var())
    print("\nStandard Deviation:")
    print(col.std())
    print("\nSkewness:")
    print(col.skew())
    print("\nCoefficient of Variation:")
    print(col.std() / col.mean())

    Q1 = col.quantile(0.25)
    Q3 = col.quantile(0.75)
    IQR = Q3 - Q1

    lower_fence = Q1 - 1.5 * IQR
    upper_fence = Q3 + 1.5 * IQR

    print("\nIQR:", IQR)
    print("\nLower Fence:", lower_fence)
    print("\nUpper Fence:", upper_fence)

calculation()

"""Loudness, tempo, and instrumentalness show symmetric distributions with negligible skewness. IQR fences suggest theoretical outliers, but due to natural bounds and domain constraints, aggressive outlier removal is not appropriate."""

sns.boxplot(y='duration_ms',data=df,color ='green',label='boxplot')
plt.title("Outliers represantation of duration_ms ",color='red')
plt.legend()

from matplotlib.markers import MarkerStyle
sns.boxplot(y='loudness',data=df,color= 'pink')
plt.title("Outliers represantation of loudness ",color='black')
plt.legend()

sns.boxplot(y='instrumentalness',data=df,color='yellow')
plt.title("Outliers represantation instrumentalness ",color='red')
plt.legend()

sns.boxplot(y='tempo',data=df)
plt.title("Outliers represantation tempo ",color='red')
plt.legend()

"""# **The Clear_data dataset was created by cleaning the stream_count column to remove outliers using a statistical filtering approach. All other numerical features in the dataset exhibited symmetrical distributions, with mean and median values approximately equal, indicating no significant skewness. Therefore, no additional transformations were required for those variables.**"""